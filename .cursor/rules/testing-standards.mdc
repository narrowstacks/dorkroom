---
globs: *.test.ts,*.test.tsx,*.spec.ts,*.spec.tsx
description: Testing standards using Vitest and React Testing Library
---

# Testing Standards

Vitest 3 + React Testing Library. Tests co-located with source using `.test.ts` or `.spec.ts` extensions.

## Commands

```bash
bun run test                    # Full verification: lint, test, build, typecheck
bun run test:unit "pattern"     # Run specific tests
```

## Test Structure

```typescript
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { describe, it, expect, vi, beforeEach } from 'vitest';

vi.mock('@dorkroom/logic', () => ({
  useBorderCalculator: vi.fn(),
}));

describe('BorderCalculator', () => {
  beforeEach(() => vi.clearAllMocks());

  describe('rendering', () => {
    it('renders calculator inputs', () => {
      render(<BorderCalculator />);
      expect(screen.getByLabelText(/paper width/i)).toBeInTheDocument();
    });
  });
});
```

## React Testing Library

### Query by Role and Label

```typescript
const button = screen.getByRole('button', { name: /calculate/i });
const input = screen.getByLabelText(/paper width/i);
const alert = screen.getByRole('alert');
```

### User Events

```typescript
import { userEvent } from '@testing-library/user-event';

it('handles user input', async () => {
  const user = userEvent.setup();
  render(<DimensionInput />);

  await user.type(screen.getByLabelText(/width/i), '210');
  expect(screen.getByLabelText(/width/i)).toHaveValue('210');
});
```

## TanStack Query Tests

Wrap with QueryClientProvider using `retry: false`:

```typescript
const createTestQueryClient = () =>
  new QueryClient({
    defaultOptions: {
      queries: { retry: false },
      mutations: { retry: false },
    },
  });

const wrapper = ({ children }: { children: React.ReactNode }) => (
  <QueryClientProvider client={createTestQueryClient()}>
    {children}
  </QueryClientProvider>
);

it('fetches data', async () => {
  const { result } = renderHook(() => useRecipe('123'), { wrapper });
  await waitFor(() => expect(result.current.isSuccess).toBe(true));
});
```

## Hook Tests

```typescript
import { renderHook, act } from '@testing-library/react';

describe('useBorderCalculator', () => {
  it('calculates border dimensions', async () => {
    const { result } = renderHook(() => useBorderCalculator());

    await act(async () => {
      await result.current.calculate({ paperWidth: 210, paperHeight: 297 });
    });

    expect(result.current.result).toEqual({
      borderTop: expect.any(Number),
      borderBottom: expect.any(Number),
    });
  });
});
```

## Mocking

```typescript
// Module mock
vi.mock('@dorkroom/logic', () => ({
  useBorderCalculator: vi.fn(),
}));

// Partial mock
vi.mock('@dorkroom/logic', async () => {
  const actual = await vi.importActual('@dorkroom/logic');
  return { ...actual, useBorderCalculator: vi.fn() };
});

// Mock implementation
const mockCalculate = vi.fn()
  .mockResolvedValueOnce({ result: 'first' })
  .mockRejectedValue(new Error('failed'));
```

## Best Practices

1. **Test behavior, not implementation** - Query by accessible roles
2. **Arrange-Act-Assert** - Clear test structure
3. **One assertion per test** when possible
4. **Descriptive names** - `'displays error when paper width exceeds maximum'`
